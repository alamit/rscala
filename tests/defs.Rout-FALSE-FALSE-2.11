> source("common.R",print.eval=TRUE)
# R version 3.4.0 (2017-04-21) # becker # FALSE # FALSE
> 
> 
> ####
> 
> 
> rng1 <- s %.~% "new scala.util.Random"
> rng1$nextDouble()
[1] 0.8038444
> 
> s$r1 <- rng1
> rng2 <- s$r1
> rng2$nextDouble()
[1] 0.7208792
> 
> rng3 <- s$.scala.util.Random$new()
> rng3$nextDouble()
[1] 0.7355114
> 
> s$r3 <- rng3
> rng4 <- s$r3
> rng4$nextDouble()
[1] 0.84189
> 
> f <- rng4$nextDouble(.EVALUATE=FALSE)
> f()
[1] 0.2836419
> 
> 
> ####
> 
> 
> see <- "David"
> mkFunc1 <- function() {
+   see <- "B."
+   x <- "Milly"
+   print(environment())
+   r <- function(x1="Mack",x2="Bob") s %!% '
+     x1+" "+x2+" "+R.getS0("see")
+   '
+   r
+ }
> y1 <- mkFunc1()
<environment: 0x288c338>
> identical(y1("Lisa","Dahl"),"Lisa Dahl B.")
[1] TRUE
> 
> 
> mkFunc2 <- function() {
+   see <- "MMMM."
+   x <- "Milly"
+   r <- function(x="Mack",y="Bob") s %.!% '
+       x+" "+y+" "+R.getS0("see")
+   '
+   r
+ }
> y2 <- mkFunc2()
> identical(y2("Lisa","Dahl")$toString(),"Lisa Dahl MMMM.")
[1] TRUE
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 349676 18.7     592000 31.7   460000 24.6
Vcells 640237  4.9    1231220  9.4  1041801  8.0
> 
> 
> 
> func1 <- function() {
+   see <- "Knudsen"
+   y1("Lisa","Dahl")
+ }
> identical(func1(),"Lisa Dahl B.")
[1] TRUE
> 
> 
> ####
> 
> 
> # Realistic timing
> system.time({
+   e <- function(x=0,y=4L,name="dog") s %!% '
+     name + " " + ( x + y )
+   '
+   scalaOptimize(e)
+ })
   user  system elapsed 
  0.000   0.000   0.407 
> 
> # Taking advantage of caching
> system.time({
+   f <- function(x=0,y=4L,name="dog") s %!% '
+     name + " " + ( x + y )
+   '
+   scalaOptimize(f)
+ })
   user  system elapsed 
  0.000   0.000   0.001 
> 
> ####
> 
> nextDouble <- function(rng=s$null("scala.util.Random")) s %!% "rng.nextDouble()"
> 
> mkRNG1 <- function() s %.!% 'new scala.util.Random()'
> mkRNG2 <- function() s %.~% 'new scala.util.Random()'
> 
> rng1 <- mkRNG1()
> rng2 <- mkRNG2()
> 
> rng1$nextInt(10L)
[1] 0
> rng2$nextInt(10L)
[1] 4
> 
> str <- rng1$toString(.AS.REFERENCE=TRUE)
> str$length()
[1] 25
> 
> nd0 <- rng1$nextDouble(.EVALUATE=FALSE)
> nd1 <- function() s %!% 'R.cached("@{toString(rng1)}").asInstanceOf[@{rng1[[\'type\']]}].nextDouble()'
> nd1b <- scalaOptimize(nd1)
> nd2 <- function() s %!% '@{rng2}.nextDouble()'
> nd2b <- scalaOptimize(nd2)
> 
> library("microbenchmark")
> 
> microbenchmark(
+   runif(1),
+   rng1$nextDouble(),
+   rng2$nextDouble(),
+   nd0(),
+   nd1(),
+   nd1b(),
+   nd2(),
+   nd2b(),
+   times=500
+ )
Unit: microseconds
              expr      min        lq       mean    median        uq        max
          runif(1)    1.666   10.1345   12.14968   12.5175   14.9065     99.384
 rng1$nextDouble() 1415.799 1544.8850 2611.60983 2027.4365 2644.7935  77150.560
 rng2$nextDouble() 1328.421 1442.9200 3770.11729 1982.7355 2487.2490 841513.795
             nd0()  223.226  276.4555  464.74199  366.3550  528.0855  14527.041
             nd1() 1310.469 1449.6655 1993.66247 1762.3655 2432.7385   9695.995
            nd1b()  230.189  280.7525  437.32597  380.3560  509.8845  10614.224
             nd2() 1222.961 1349.9405 1916.38331 1812.0715 2326.1875  11382.185
            nd2b()  224.893  274.5220  392.61374  382.7070  501.5665   1062.150
 neval
   500
   500
   500
   500
   500
   500
   500
   500
> 
> ####
> 
> f <- function(x=4) {
+   if ( x < 0 ) stop("'x' must be positive")
+   if ( x == 0 ) x <- 10
+   s %!% '2*x'
+ }
> 
> f(4)
[1] 8
> tryCatch(f(-3), error=function(e) e)
<simpleError in f(-3): 'x' must be positive>
> f(0)
[1] 20
> 
> g <- scalaOptimize(f)
> g(4)
[1] 8
> g(-3)     ## Note that no error because R code as been optimized away!
[1] -6
> g(0)      ## And we don't get the special case when x==0.
[1] 0
> 
> h <- function(x=4) {
+   if ( x < 0 ) stop("'x' must be positive")
+   if ( x == 0 ) x <- 10
+   s %~% '2*R.getD0("x")'
+ }
> 
> h(4)
[1] 8
> tryCatch(h(-3), error=function(e) e)
<simpleError in h(-3): 'x' must be positive>
> h(0)
[1] 20
> 
> library(microbenchmark)
> microbenchmark(
+   f(4),
+   g(4),
+   h(4),        # h is *slow* and it has the memory leak inherent in Scala's REPL.
+   times=100)
Unit: microseconds
 expr       min          lq       mean     median         uq       max neval
 f(4)  1330.003   2193.0075   4228.286   2579.974   2953.601  32263.23   100
 g(4)   385.204    588.2165   2074.955    648.891    787.832  90558.65   100
 h(4) 84958.714 139991.4050 182062.073 166546.464 216915.981 380490.26   100
> 
> microbenchmark(
+   f(4),        
+   g(4),        # g is faster, but you lose the checking and special behavior.
+   times=1000)
Unit: microseconds
 expr      min        lq      mean   median        uq      max neval
 f(4) 1269.004 1870.9775 3191.7711 1982.728 2297.7965 87461.12  1000
 g(4)  307.334  527.7305  957.3182  599.217  674.9725 53763.71  1000
> 
> 
> 
> 
> ####
> 
> s$.scala.util.Random$nextDouble()
[1] 0.1177923
> m <- s$.scala.util.Random$new(342L,.EVALUATE=FALSE)
> m(23436)$nextDouble()
[1] 0.8011135
> m(63502)$nextDouble()
[1] 0.1435077
> m(93222)$nextDouble()
[1] 0.4889048
> m(93222)$nextDouble()
[1] 0.4889048
> 
> n <- m(5)$nextDouble(.EVALUATE=FALSE)
> n()
[1] 0.7305199
> n()
[1] 0.08825841
> n()
[1] 0.4889045
> 
> s$'.Array[Int]'$new(5L)
[1] 0 0 0 0 0
> 
> ####
> 
> s$a <- 1:10
> a <- s$.a
> a$apply(3L)
[1] 4
> 
> s$.scala.util.Random$nextDouble()
[1] 0.01054264
> s$.scala.util.Random$nextDouble()
[1] 0.2426814
> 
> s %@% 'import scala.util.Random'
> s$.Random$nextDouble()
[1] 0.9350686
> 
> a <- function() s %!% 'Random.nextDouble'
> a()
[1] 0.2158671
> 
> a <- s$.scala.util.Random
> a$nextDouble()
[1] 0.2895903
> 
> b <- ( function() s %!% 'scala.util.Random' )()
> b$nextDouble()
[1] 0.9267482
> 
> library(microbenchmark)
> microbenchmark(
+   a$nextDouble(),
+   b$nextDouble(),
+   times=1000
+   )
Unit: milliseconds
           expr      min       lq     mean   median       uq      max neval
 a$nextDouble() 1.527905 2.378787 5.113534 2.549506 3.049745 73.49392  1000
 b$nextDouble() 1.505846 2.529731 5.233496 2.709354 2.960867 97.88829  1000
>   
> 
> ####
> 
> f <- function(x=NULL, wantNull=TRUE) s %.!% '
+   val r = R.makePersistent(x)
+   if ( wantNull ) null else r
+ '
> 
> a <- f(1:10, FALSE)
> a$name()
[1] ".rsI[['r']]$uBhXx4SE"
> 
> g <- function(func=NULL,y=scalaNull("RPersistentReference")) s %!% '
+   R.invoke(func,y)
+ '
> 
> g(print, a)
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> 
> ####
> 
> f <- function(x=scalaNull("(Int,Int)")) s %!% 'x._1 + x._2'
> g <- s %~% "(300,400)"
> f(g)
[1] 700
> f(s %.~% "(30,40)")
[1] 70
> 
> f2 <- function() s %~% 'println("Yes")'
> f2()
> capture.output(f2())
character(0)
> 
> a <- s %.~% "(300,234)"
> f1 <- function(x=scalaNull("(Int,Int)"),y=numeric()) s %!% 'x._1 + x._2 + y.sum'
> f1(a,c(2,3,4,6))
[1] 549
> 
> f1 <- function(x=scalaNull("(Int,Int)"),y=scalaNull("Array[Double]")) s %!% 'x._1 + x._2 + y.sum'
> b <- s %.~% "Array[Double](2,3,4,5)"
> f1(a,b)
[1] 548
> 
> ####
> 
> (function() s %!% 'println("Yes")')()
> (function() s %!% '0')()
[1] 0
> (function() s %!% 'null')()
> 
> ####
> 
> tryCatch((function() s %!% 'a+b')(),error = function(e) e)
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'a+')(),error = function(e) e)
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'import org.asdfad')(),error = function(e) {e})
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'throw new RuntimeException()')(),error = function(e) {e})
<simpleError in (structure(function () {    .rsI <- .rsWn9tP7q03    .rsWorkspace <- environment()    rscala:::wb(.rsI, rscala:::INVOKE)    rscala:::wc(.rsI, "res154")    flush(.rsI[["socketIn"]])    rscala:::rServe(.rsI, TRUE, .rsWorkspace)    .rsStatus <- rscala:::rb(.rsI, "integer")    if (.rsStatus == rscala:::ERROR) {        stop("Invocation error.")    }    else {        .rsResult <- rscala:::scalaGet(.rsI, "?", NA)        if (is.null(.rsResult))             invisible(.rsResult)        else .rsResult    }}, identifiers = character(0), scalaHeader = character(0), scalaBody = "throw new RuntimeException()", returnType = "Nothing", asReference = NA, class = "ScalaFunction"))(): Invocation error.>
> s %~% "5+6"   # Everything's still okay!
[1] 11
> 
> 
