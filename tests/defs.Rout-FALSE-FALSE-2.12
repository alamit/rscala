> source("common.R",print.eval=TRUE)
# R Under development (unstable) (2017-04-25 r72623) # ramah # FALSE # FALSE
> 
> 
> ####
> 
> 
> rng1 <- s %.~% "new scala.util.Random"
> rng1$nextDouble()
[1] 0.3085792
> 
> s$r1 <- rng1
> rng2 <- s$r1
> rng2$nextDouble()
[1] 0.1403883
> 
> rng3 <- s$.scala.util.Random$new()
> rng3$nextDouble()
[1] 0.1736714
> 
> s$r3 <- rng3
> rng4 <- s$r3
> rng4$nextDouble()
[1] 0.3747797
> 
> f <- rng4$nextDouble(.EVALUATE=FALSE)
> f()
[1] 0.8833797
> 
> 
> ####
> 
> 
> see <- "David"
> mkFunc1 <- function() {
+   see <- "B."
+   x <- "Milly"
+   print(environment())
+   r <- function(x1=I("Mack"),x2=I("Bob")) s %!% '
+     x1+" "+x2+" "+R.getS0("see")
+   '
+   r
+ }
> y1 <- mkFunc1()
<environment: 0x3c84a80>
> identical(y1("Lisa","Dahl"),"Lisa Dahl B.")
[1] TRUE
> 
> 
> mkFunc2 <- function() {
+   see <- "MMMM."
+   x <- "Milly"
+   r <- function(x=I("Mack"),y=I("Bob")) s %.!% '
+       x+" "+y+" "+R.getS0("see")
+   '
+   r
+ }
> y2 <- mkFunc2()
> identical(y2("Lisa","Dahl")$toString(),"Lisa Dahl MMMM.")
[1] TRUE
> gc()
         used (Mb) gc trigger (Mb) max used (Mb)
Ncells 336665 18.0     592000 31.7   460000 24.6
Vcells 629069  4.8    1207128  9.3  1018856  7.8
> 
> 
> 
> func1 <- function() {
+   see <- "Knudsen"
+   y1("Lisa","Dahl")
+ }
> identical(func1(),"Lisa Dahl B.")
[1] TRUE
> 
> 
> ####
> 
> 
> # Realistic timing
> system.time({
+   e <- function(x=I(0),y=I(4L),name=I("dog")) s %!% '
+     name + " " + ( x + y )
+   '
+   scalaOptimize(e)
+ })
   user  system elapsed 
  0.004   0.000   0.454 
> 
> # Taking advantage of caching
> system.time({
+   f <- function(x=I(0),y=I(4L),name=I("dog")) s %!% '
+     name + " " + ( x + y )
+   '
+   scalaOptimize(f)
+ })
   user  system elapsed 
  0.004   0.000   0.001 
> 
> ####
> 
> nextDouble <- function(rng=s$null("scala.util.Random")) s %!% "rng.nextDouble()"
> 
> mkRNG1 <- function() s %.!% 'new scala.util.Random()'
> mkRNG2 <- function() s %.~% 'new scala.util.Random()'
> 
> rng1 <- mkRNG1()
> rng2 <- mkRNG2()
> 
> rng1$nextInt(I(10L))
[1] 1
> rng2$nextInt(I(10L))
[1] 5
> 
> str <- rng1$toString(.AS.REFERENCE=TRUE)
> str$length()
[1] 26
> 
> nd0 <- rng1$nextDouble(.EVALUATE=FALSE)
> nd1 <- function() s %!% 'R.cached("@{toString(rng1)}").asInstanceOf[@{rng1[[\'type\']]}].nextDouble()'
> nd1b <- scalaOptimize(nd1)
> nd2 <- function() s %!% '@{rng2}.nextDouble()'
> nd2b <- scalaOptimize(nd2)
> 
> library("microbenchmark")
> 
> microbenchmark(
+   runif(1),
+   rng1$nextDouble(),
+   rng2$nextDouble(),
+   nd0(),
+   nd1(),
+   nd1b(),
+   nd2(),
+   nd2b(),
+   times=500
+ )
Unit: microseconds
              expr     min        lq        mean    median        uq       max
          runif(1)   1.167    7.9760    9.761902   10.0745   12.2895     65.63
 rng1$nextDouble() 961.675 1278.2070 2072.155500 1945.4915 2140.2515  65277.95
 rng2$nextDouble() 905.271 1185.0625 2185.141380 1819.2275 2021.4980 193251.16
             nd0() 141.617  221.6230  403.298114  363.2030  403.8690  13242.27
             nd1() 901.942 1208.9525 1866.940586 1777.4905 1987.5970  26123.00
            nd1b() 162.244  234.5940  446.923150  370.3750  419.9150  40593.52
             nd2() 872.914 1090.0035 1691.531560 1668.8375 1849.9040  14807.89
            nd2b() 150.683  222.4265  377.344690  343.1145  402.2620  11550.66
 neval
   500
   500
   500
   500
   500
   500
   500
   500
> 
> ####
> 
> f <- function(x=4) {
+   if ( x < 0 ) stop("'x' must be positive")
+   if ( x == 0 ) x <- 10
+   s %!% '2*x.sum'
+ }
> 
> f(4)
[1] 8
> tryCatch(f(-3), error=function(e) e)
<simpleError in f(-3): 'x' must be positive>
> f(0)
[1] 20
> 
> g <- scalaOptimize(f)
> g(4)
[1] 8
> g(-3)     ## Note that no error because R code as been optimized away!
[1] -6
> g(0)      ## And we don't get the special case when x==0.
[1] 0
> 
> h <- function(x=4) {
+   if ( x < 0 ) stop("'x' must be positive")
+   if ( x == 0 ) x <- 10
+   s %~% '2*R.getD1("x").sum'
+ }
> 
> h(4)
[1] 8
> tryCatch(h(-3), error=function(e) e)
<simpleError in h(-3): 'x' must be positive>
> h(0)
[1] 20
> 
> library(microbenchmark)
> microbenchmark(
+   f(4),
+   g(4),
+   h(4),        # h is *slow* and it has the memory leak inherent in Scala's REPL.
+   times=100)
Unit: microseconds
 expr       min         lq       mean      median          uq       max neval
 f(4)  1207.477   1944.793   2801.424   2092.1330   2294.8380  29829.51   100
 g(4)   289.581    479.719   1005.520    592.4915    687.4475  21504.92   100
 h(4) 94148.226 132670.967 212478.679 171346.1125 275801.2135 555273.66   100
> 
> microbenchmark(
+   f(4),        
+   g(4),        # g is faster, but you lose the checking and special behavior.
+   times=1000)
Unit: microseconds
 expr     min        lq      mean   median        uq       max neval
 f(4) 973.553 1491.2205 1794.2665 1764.662 1935.3195 47347.954  1000
 g(4) 257.676  363.8555  511.8788  463.798  582.0255  8586.308  1000
> 
> 
> 
> 
> ####
> 
> s$.scala.util.Random$nextDouble()
[1] 0.3453944
> m <- s$.scala.util.Random$new(I(342L),.EVALUATE=FALSE)
> m(23436)$nextDouble()
[1] 0.8011135
> m(63502)$nextDouble()
[1] 0.1435077
> m(93222)$nextDouble()
[1] 0.4889048
> m(93222)$nextDouble()
[1] 0.4889048
> 
> n <- m(5)$nextDouble(.EVALUATE=FALSE)   # Wrapping with I() is not needed.
> n()
[1] 0.7305199
> n()
[1] 0.08825841
> n()
[1] 0.4889045
> 
> s$'.Array[Int]'$new(I(5L))
[1] 0 0 0 0 0
> 
> ####
> 
> s$a <- 1:10
> a <- s$.a
> a$apply(I(3L))
[1] 4
> tryCatch(a$apply(3L),error=function(e) e)  # Needs to be wrapped in I().
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> 
> s$.scala.util.Random$nextDouble()
[1] 0.4056813
> s$.scala.util.Random$nextDouble()
[1] 0.6722176
> 
> s %@% 'import scala.util.Random'
> s$.Random$nextDouble()
[1] 0.2155956
> 
> a <- function() s %!% 'Random.nextDouble'
> a()
[1] 0.7882851
> 
> a <- s$.scala.util.Random
> a$nextDouble()
[1] 0.9661104
> 
> b <- ( function() s %!% 'scala.util.Random' )()
> b$nextDouble()
[1] 0.4481441
> 
> library(microbenchmark)
> microbenchmark(
+   a$nextDouble(),
+   b$nextDouble(),
+   times=1000
+   )
Unit: microseconds
           expr     min       lq     mean   median       uq      max neval
 a$nextDouble() 887.094 1230.629 1914.843 1871.073 2052.513 54875.11  1000
 b$nextDouble() 945.282 1379.181 1917.478 1989.724 2179.768 23419.05  1000
>   
> 
> ####
> 
> f <- function(x=NULL, wantNull=I(TRUE)) s %.!% '
+   val r = R.makePersistent(x)
+   if ( wantNull ) null else r
+ '
> 
> a <- f(1:10, FALSE)
> a$name()
[1] ".rsI[['r']]$RSeduNrP"
> 
> g <- function(func=NULL,y=scalaNull("RPersistentReference")) s %!% '
+   R.invoke(func,y)
+ '
> 
> g(print, a)
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> 
> ####
> 
> f <- function(x=scalaNull("(Int,Int)")) s %!% 'x._1 + x._2'
> g <- s %~% "(300,400)"
> f(g)
[1] 700
> f(s %.~% "(30,40)")
[1] 70
> 
> f2 <- function() s %~% 'println("Yes")'
> f2()
> capture.output(f2())
character(0)
> 
> a <- s %.~% "(300,234)"
> f1 <- function(x=scalaNull("(Int,Int)"),y=numeric()) s %!% 'x._1 + x._2 + y.sum'
> f1(a,c(2,3,4,6))
[1] 549
> 
> f1 <- function(x=scalaNull("(Int,Int)"),y=scalaNull("Array[Double]")) s %!% 'x._1 + x._2 + y.sum'
> b <- s %.~% "Array[Double](2,3,4,5)"
> f1(a,b)
[1] 548
> 
> ####
> 
> (function() s %!% 'println("Yes")')()
> (function() s %!% '0')()
[1] 0
> (function() s %!% 'null')()
> 
> ####
> 
> tryCatch((function() s %!% 'a+b')(),error = function(e) e)
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'a+')(),error = function(e) e)
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'import org.asdfad')(),error = function(e) {e})
<simpleError in scalaEval(interpreter, snippet, workspace): Error in evaluation.>
> tryCatch((function() s %!% 'throw new RuntimeException()')(),error = function(e) {e})
<simpleError in (structure(function () {    .rsI <- .rsWEXrTBKJ8    .rsWorkspace <- environment()    rscala:::wb(.rsI, rscala:::INVOKE)    rscala:::wc(.rsI, "res155")    flush(.rsI[["socketIn"]])    rscala:::rServe(.rsI, TRUE, .rsWorkspace)    .rsStatus <- rscala:::rb(.rsI, "integer")    if (.rsStatus == rscala:::ERROR) {        stop("Invocation error.")    }    else {        .rsResult <- rscala:::scalaGet(.rsI, "?", NA)        if (is.null(.rsResult))             invisible(.rsResult)        else .rsResult    }}, identifiers = character(0), scalaHeader = character(0), scalaBody = "throw new RuntimeException()", returnType = "Nothing", asReference = NA, class = "ScalaFunction"))(): Invocation error.>
> s %~% "5+6"   # Everything's still okay!
[1] 11
> 
> 
